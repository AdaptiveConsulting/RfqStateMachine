{"name":"RFQ State Machine","tagline":"A sample event driven state machine using Stateless","body":"# RFQ State Machine\r\n\r\nWe highlighted quite a few techniques to deal with reactive systems in [Reactive Trader](https://github.com/AdaptiveConsulting/ReactiveTrader). There is another one, that we commonly use, that was not demonstrated. \r\nA *state machine* is a simple yet powerfull way of decomposing some functionality into *states* and a set of valid *transitions* between them. \r\nWhen you find yourself dealing for instance with user input and/or server events and see lots of branching in your code (if/switch statements) on some _state variables, chances are high that a statemachine could be introduced to simplify things.\r\n\r\nIn this post we will look at a concreate usecase, we will define a state machine for it and we will see how we can organise our code around the state machnine and interact with it. \r\n\r\n## Example: RFQ workflow\r\n\r\nIn finance Request For Quote (RFQ) is a common mechanism used to request a price electronically: the client submits a request to the pricing server. \r\nAt some point the server provides a quote (or a serie of quotes) and the client can decide to execute (HIT the price) or pass (cancel).\r\nWe are going to build a state machine that would live client side, in some UI application like [reactive trader](https://github.com/AdaptiveConsulting/ReactiveTrader), to control the state of a RFQ.\r\n\r\nThe following diagram describes the different states of the RFQ and the possible transitions.\r\n\r\n![state machine diagram](https://raw.githubusercontent.com/AdaptiveConsulting/RfqStateMachine/master/StateMachine.PNG?token=1256913__eyJzY29wZSI6IlJhd0Jsb2I6QWRhcHRpdmVDb25zdWx0aW5nL1JmcVN0YXRlTWFjaGluZS9tYXN0ZXIvU3RhdGVNYWNoaW5lLlBORyIsImV4cGlyZXMiOjE0MDQwMzI4NDN9--33bd8eef1b0c9c1064f9d1844ed8f99cb19b96b4)\r\n\r\nThis is a visual representation of a statemachine, it contains \r\n\r\n - states:\r\n   - an initial state (at the top),\r\n   - intermediate states (requesting, quoted, Executing)\r\n   - terminal states (Error, Done, Canceled)\r\n - and transitions between states (arrows)\r\n\r\nI find those diagrams very helpfull to think about the system, while building them I will generally go through all the states I already discovered and ask myself the following questions: \r\n\r\n - could anything else happen in this state? \r\n - Any unhappy path? (ie. timeout, error, etc) \r\n - Do we have a representation of this particular state for the corresponding UI? (if you are building a UI).\r\n\r\nThose diagrams are also very usefull to discuss with non developers: business people, UX, etc.\r\n\r\n## From diagram to code\r\n\r\nStatemachines can be implemented in many differents ways, either from scratch or using some library. \r\nFor any decent size statemachine I tend to use [Stateless](https://code.google.com/p/stateless/) but the recommendations that follow would stand for any library or hand written statemachine.\r\n\r\nI like to define state machines in a single place: I find that spreading the definition accross multiple files/classes makes it harder to understand.\r\n\r\nStateless offers a nice fluent syntax to define states and possible transitions. \r\n\r\n###Defining states\r\n\r\n\r\nThe first thing we need to do is to define the set of states, we can use an enum for that:\r\n\r\n```csharp\r\npublic enum RfqState\r\n{\r\n    Input,\r\n    Requesting,\r\n    Cancelling,\r\n    Cancelled,\r\n    Quoted,\r\n    Executing,\r\n    Error,\r\n    Done\r\n}\r\n```\r\n[gist](https://gist.github.com/odeheurles/9160c1b3e0687d3ebf38#file-rfqstates)\r\n\r\n###Events\r\n\r\nThen we define the events which will trigger transitions between states. In our case those are events coming from the client or from the server. \r\n\r\nAgain we can use an enum to define those events.\r\n\r\n\r\n```csharp\r\npublic enum RfqEvent\r\n{\r\n    UserRequests,\r\n    UserCancels,\r\n    UserExecutes,\r\n\r\n    ServerNewQuote,\r\n    ServerQuoteError,\r\n    ServerQuoteStreamComplete,\r\n    ServerSendsExecutionReport,\r\n    ServerExecutionError,\r\n    ServerCancelled,\r\n    ServerCancellationError,\r\n\r\n    InternalError,\r\n}\r\n```\r\n[gist](https://gist.github.com/odeheurles/14bbd2a0b8040a808356#file-rfqevent)\r\n\r\nI like to prefix those events with their origin, just to makes things explicit (here we have 'Server', 'User', 'Internal')\r\n\r\nAs you can see events coming from the server always expose a happy path (for instance ServerNewQuote when the server sends a new quote) and at least one corresponding error event (ServerQuoteError).\r\n\r\n![Components](https://raw.githubusercontent.com/AdaptiveConsulting/RfqStateMachine/master/Components.PNG?token=1256913__eyJzY29wZSI6IlJhd0Jsb2I6QWRhcHRpdmVDb25zdWx0aW5nL1JmcVN0YXRlTWFjaGluZS9tYXN0ZXIvQ29tcG9uZW50cy5QTkciLCJleHBpcmVzIjoxNDA0MDMyOTYxfQ%3D%3D--f635d386ef4ee480652de98f62d9903fc2660e25)\r\n\r\n\r\nYou will also often have internal events, for instance a timer expiring can raise an internal event to trigger a state transition.\r\n\r\nEvents may or not carry some data: for instance UserRequests event needs to contain the description of the product being priced.\r\nFor those events requiring parameters it is useful to define strongly typed events. \r\n\r\nThis is how we declare them with Stateless, for instance for the ServerSendsQuote event:\r\n\r\n```csharp\r\n_rfqEventServerSendsQuote = _stateMachine.SetTriggerParameters<IQuote>(RfqEvent.ServerNewQuote);\r\n```\r\n[gist](https://gist.github.com/odeheurles/dea91fa626e6b468ef07#file-stronglytypedevent)\r\n\r\n###Defining transitions\r\n\r\nNow we can define transitions. For each state we define which events are allowed and when they are triggered to which state we will transition.\r\nThis is very straight forward with stateless:\r\n\r\n```csharp\r\n_stateMachine.Configure(RfqState.Input)\r\n             .Permit(RfqEvent.UserRequests, RfqState.Requesting);\r\n\r\n_stateMachine.Configure(RfqState.Requesting)\r\n             .Permit(RfqEvent.ServerNewQuote, RfqState.Quoted)\r\n             .Permit(RfqEvent.UserCancels, RfqState.Cancelling)\r\n             .Permit(RfqEvent.InternalError, RfqState.Error);\r\n\r\n_stateMachine.Configure(RfqState.Quoted)\r\n             .PermitReentry(RfqEvent.ServerNewQuote)\r\n             .Permit(RfqEvent.UserCancels, RfqState.Cancelling)\r\n             .Permit(RfqEvent.UserExecutes, RfqState.Executing);\r\n\r\n_stateMachine.Configure(RfqState.Executing)\r\n             .Permit(RfqEvent.ServerSendsExecutionReport, RfqState.Done);\r\n\r\n_stateMachine.Configure(RfqState.Cancelling)\r\n             .Permit(RfqEvent.ServerCancelled, RfqState.Cancelled);\r\n```\r\n[gist](https://gist.github.com/odeheurles/2a0ef6112f33d9f2425d)\r\n\r\n### Triggering events\r\n\r\nWhen the user performs an action or the server sends back a message we want to fire an event at the state machine.\r\nThis is straight forward with stateless\r\n\r\n```csharp\r\n// for an event without parameters\r\n_stateMachine.Fire(RfqEvent.ServerQuoteStreamComplete)\r\n\r\n// for a strongly typed event\r\n_stateMachine.Fire(_rfqEventServerSendsExecutionReport, executionReport)\r\n```\r\n\r\n###Defining actions\r\n\r\nWhen we send an event to the state machine, two things can happen, the current state has a valid transition for this event or not. \r\n\r\nIf the current state can accept an event we generally want to execute our code at some point around the transition:\r\n\r\n - when you enter a state (or re-enter a state since it's also possible to have transitions looping back on the same state)\r\n - when you exit a state\r\n - upon transition, if you have different behavior to implement for different transitions leading to a same state\r\n\r\nI tend to apply actions upon entry into a state and use the other variants only in specific scenarios.\r\n\r\n**Important: when implementing a statemachine, you want to put all your logic inside those actions (on state entry, on state exit, on transition) because the state machine has already checked that the incoming event was valid for the current state.**\r\n\r\nHere is an example with Stateless syntax. When the user requests a quote we want to log the transition and also to perform some logic on entry in the requesting state:\r\n\r\n```csharp\r\n_stateMachine.Configure(RfqState.Requesting)\r\n                .OnEntry(LogTransition)\r\n                .OnEntryFrom(_rfqEventUserRequests, OnEntryRequesting)\r\n                .Permit(RfqEvent.ServerNewQuote, RfqState.Quoted)\r\n                .Permit(RfqEvent.UserCancels, RfqState.Cancelling)\r\n                .Permit(RfqEvent.InternalError, RfqState.Error);\r\n\r\nprivate void OnEntryRequesting(IQuoteRequest quoteRequest)\r\n{\r\n    // here goes the code to send a quote request to the server\r\n}\r\n```\r\n\r\n**Tip**: you can think of the OnExit action as a Dispose() method for the corresponding state. It is very useful if for instance you had a timer runing during that state and you need to cancel it or you have whatever active Rx query that you want to unsubscribe.\r\n\r\n### Handling errors\r\n\r\nWhen an event is fired at the state machine and the state machine has no transition defined for this event in the current state we can implement 2 behaviors: ignoring the event or raising an exception.\r\n\r\nBy default Stateless will raise an exception but you can handle yourself invalid transitions:\r\n\r\n```csharp\r\n_stateMachine.OnUnhandledTrigger(OnUnhandledTrigger);\r\n\r\nprivate void OnUnhandledTrigger(RfqState state, RfqEvent trigger)\r\n{\r\n    var message = string.Format(\"State machine received an invalid trigger '{0}' in state '{1}'\", trigger, state);\r\n    Console.WriteLine(message);\r\n\r\n    _rfqUpdateSubject.OnError(new ApplicationException(message));\r\n}\r\n```\r\n\r\nYou can also ignore individual events on a state with the Stateless *.Ignore()* method.\r\n\r\n### Encapsulation\r\n\r\nWe have now defined everything we need for the state machine:\r\n - states,\r\n - events and strongly typed events\r\n - possible transitions\r\n - actions on entry and on exit\r\n - error handling\r\n - how to fire events at the state machine\r\n\r\nThe next step is to encapsulate everything in a single class so we don't leak the specifics of Stateless and the state machine to the rest of our code.\r\n\r\nFor our example I've created a class **Rfq** that you can find [here](https://github.com/AdaptiveConsulting/RfqStateMachine/blob/master/RfqStateMachine/Rfq.cs).\r\n\r\nThis class implements the following interface:\r\n\r\n```csharp\r\npublic interface IRfq : IDisposable\r\n{\r\n    void RequestQuote(IQuoteRequest quoteRequest);\r\n    void Cancel(long rfqId);\r\n    void Execute(IExecutionRequest quote);\r\n\r\n    IObservable<RfqUpdate> Updates { get; } \r\n}\r\n```\r\n\r\nThis is very much CQRS style: a view model can call the RequestQuote, Cancel and Execute methods which act as Commands and internally fire events. Don't get confused by 'Command' and 'Event', they are the same, it's just that in the context of CQRS we talk about commands and for state machine I've use the term event from the beginning (we could use message as well if we want).\r\n\r\nThe view model also subscribes to the Updates stream which will notify when the state machine transitions and provide the relevant data (a quote, an execution report, etc).\r\n\r\nYou can find some sample usage of this API in the [test project](https://github.com/AdaptiveConsulting/RfqStateMachine/blob/master/Tests/RfqStateMachineTests.cs).\r\n\r\n![Encapsulation](https://raw.githubusercontent.com/AdaptiveConsulting/RfqStateMachine/master/Encapsulation.PNG?token=1256913__eyJzY29wZSI6IlJhd0Jsb2I6QWRhcHRpdmVDb25zdWx0aW5nL1JmcVN0YXRlTWFjaGluZS9tYXN0ZXIvRW5jYXBzdWxhdGlvbi5QTkciLCJleHBpcmVzIjoxNDA0MTMyMzkwfQ%3D%3D--33adc46c203e50b1adbb54dcdbc27c98faf1d0be)\r\n\r\n### Concurrency\r\n\r\nI would strongly suggest to get your state machine running on a single thread. In my example the view model MUST call from the UI thread (Dispatcher) and I explicitly marshal server side initiated messages to the UI thread using ObserveOn in my Rx queries.\r\n\r\nIf you are not building a UI you should consider running your statemachine in an actor or an event loop: anything that will guarantee that calls made on the state machine are sequenced and do not have to be synchronized.\r\n\r\nWhy? Simply because otherwise you will have to synchronise all accesses to the state machine (and other states in your encasulating class) with locks. If for instance you take a lock while firing an event, all the actions will run under that lock. Those actions will likely call on code external to this class and you now have risks of deadlock.. \r\n\r\n### Race conditions\r\n\r\nNever forget that in an event driven system things can happen in an order you do not expect, and your state machine should be ready for that.\r\n\r\nHere is an example, which use a slightly different protocol for the RFQ:\r\n\r\n - the user receives a valid quote Q1 from the server\r\n - the server sends an invalid quote message (to invalidate the quote because the market has moved or for whatever reason)\r\n - the user HIT the quote Q1 (executes) while the invalidation message is still in flight (ie. still travelling somewhere between the server and the client)\r\n - the state machine transitions to the state 'Executing'\r\n - the client receives the invalidate quote message/event but the state machine is in a state where you might not have expected to receive such event...\r\n\r\nBecause there is a propagation delay between a client and a server, you will see behaviors in your systems that you did not thought about initially and that you have probably not covered in your unit tests. \r\n\r\nWhat to do about it?\r\n\r\n1. For each state go through the list of all possible events and ask yourself: could this one possibly happen in this state? If it does, how should it be handled?\r\n2. Log all transitions of the state machine and all events fired. This is priceless while investigating for such issues.\r\n3. Unit testing is not enough, you will need to test in a deployed environment.\r\n\r\n## Wrap up\r\n\r\nIt takes a bit of time to get your head around state machines but once you get it those little things yield very nice clean code and it's also very simple to introduce new state and transitions if you follow the few guidelines we discussed here.\r\n\r\nThere are a few other things I'd like to talk about with state machines (for instance visualising them while the system is running, code generation, etc) but we will cover that in a future blog post.\r\n\r\nI would also suggest to have a look to the work of Pieter Hintjens (ZeroMQ) on state machines and code generation, he has done some [very cool stuff in this area](https://github.com/zeromq/zproto) ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}